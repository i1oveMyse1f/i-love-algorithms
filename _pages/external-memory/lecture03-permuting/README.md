---
layout: lecture
title:  "Перестановка во внешней памяти"
author: i_love_myself
categories: [ external_memory, sorting ]
toc: true
---

## Задача

В RAM-модели переставить элементы в массиве согласно заданной перестановке $\pi(n)$ (англ. _permutation problem_) - это простейшая задача, которая решается за $O(N)$ одним проходом по массиву (то есть по данному массиву $a_k$ нужно построить массив $b_k = a_{\pi(k)}$). Однако в модели внешней памяти (EM модель) мы получим более эффективный алгоритм и даже докажем его оптимальность.

<div markdown="1" class="alert alert-theorem">
Пусть в EM модели есть массив размера $N$, который нужно переставить согласно заданной перестановке $\pi(n)$, тогда существует алгоритм, время работы которого $O(\min(N, \frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B}))$. Более того, если модель удовлетворяет indivisibility assumption, то быстрее нельзя.
</div>

## Что такое indivisibility assumption?

Indivisibility assumption - это по сути другая модель внешней памяти, которая с одной стороны крайне похожа на EM модель, но с другой - имеет несколько ключевых различий. В Indivisibility Model мы будем иметь всё те же три параметра $M$, $N$ и $B$, однако набор операций чуть-чуть отличается:

* $Read(e, B)$ - это операция чтения блока данных из внешней памяти в котором содержится элемент $e$
* $Write(e, B)$ - это операция записи блока данных во внешнюю память, в котором содержится элемент $e$
* Все операции над элементами в RAM **неизменяемые (atomic)** и выполняются за $O(1)$, то есть вы не можете менять элементы из инпута - они являются "неделимыми" единицами информации.
* Для простоты анализа мы будем разрешать оперировать только целиком блоками размера $B$

С одной стороны данная модель сильнее, чем EM модель, поскольку она умеет  **волшебным образом** доставать нужный вам элемент из произвольного места во внешней памяти без полного ее сканирования. С другой стороны она слабее, поскольку не позволяет вам делать произвольные операции над элементами массива, а только операции чтения и записи.

Для наглядности можно сузить EM модель до EM atomic model, тогда получим пересечение двух моделей. Кроме того, можно представить что EM comparation model - это почти EM atomic model, но с дополнительно операцией сравнения двух элементов (она пригодится нам дальше для доказательства оптимальности сортировки). Диаграма доступных операций в разных моделях будет выглядеть следующим образом:

![diagram of models](img/diagram.png){:width="50%"}

Таким образом, indivisibility assumption - удобная модель для нижней оценки времени работы алгоритма, которая позволяет нам не задуматься о том, какие операции доступны над элементами массива.

## Доказательство

### Построение алгоритма

Есть два простейших алгоритма, которые решают эту задачу: мы можем в лоб, как в RAM-модели, пройтись по массиву и записать элементы в нужные места, это будет случай с $O(n)$ оценкой. Второй случай - это отсортировать массив пар $(\pi(i), a_i)$, что займет $O(\frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B})$, таким образом мы получим верхнюю оценку на время работы алгоритма как минимум из двух алгоритмов. Важно заметить, что оба алгоритма удовлетворяют indivisibility assumption.

### Оптимальность

**Шаг 1.** Зафиксируем произвольный алгоритм перестановки, пусть в нём было $H$ операций чтения и записи. Мы можем рассматривать только алгоритмы с $H \leq n^2$, в противном случае нижняя оценка доказана

**Шаг 2.** Будем думат о блоке длины $B$ как о **неупорядоченном (мульти)множестве**, поскольку за 1 операцию мы можем загрузить их во внутреннюю память и расставить в произвольном порядке. Поэтому мы будем называть блок **использованным**, если блок как неупорядоченное множество уже передавался из внешней памяти во внутреннюю или наоборот

**Шаг 3.** Определим **состояние** алгоритма, как набор некоторых мультимножеств: первое мультимножество - это вся внутянняя память (поскольку мы мы можем ее упорядочить как нам вздумается), после него будут идти все когда-либо использованные блоки в течение работы алгоритма (правда эти блоки мы можем менять операцией вывода).

**Шаг 4.** По определению $H$ количество мультимножеств в состоянии алгоритма не превосходит $H$ (иначе мы за одну операцию ввода-вывода добавили в состояние больше $1$ мультимножества, что невозможно)

**Шаг 5.** Как может меняться состояние алгоритма в зависимости от операции?

* Read - мы вытаскиваем произвольный блок из состояния (не больше $H$ варианттов) и вставляем его в произвольное место внутренней памяти (в точности $C_{M}^B$ вариантов)
* Write - мы вытаскиваем произвольный блок из внутренней памяти (в точности $C_{M}^B$ вариантов) и вставляем его в произвольное место состояния между существующими блоками (не больше $H$ вариантов) или заменяем произвольный блок состояния (еще не больше $H$ вариантов)

Итого после одной проивольной операции состояние может стать одним из $3H C_M^B$ возможных. Соответственно после $H$ операций состояние может стать одним из $(3H C_M^B)^{H}$, а имея $H < n^2$ получаем верхнюю оценку в $(3n^2 C_M^B)^{H}$

**Шаг 6.** Алгоритм обязан уметь генерировать каждую из возможных перестановок. Всего перестновок $n!$, но различаемых из них всего лишь $\frac{n!}{(B!)^{\frac{N}{B}}}$, поскольку блоки размера $B$ не различимы (с точки зрения того, что блоки размера $B$ могут быть переставлены за 1 операцию).

**Шаг 7.** Таким образом, мы получили неравенство: количество возможных состояние алгоритма (как его выход) должен быть больше количества разлимых перестановок, то есть:

$$
(3n^2 C_M^B)^{H} \geq \frac{n!}{(B!)^{\frac{N}{B}}}
$$

Или, взяв логарифм,

$$
H \ln \left((3n^2)C_M^B\right) \geq \ln n! - \frac{N}{B} \ln B!
$$

Неравенство простейшим образом доказывается с помощью оценки факториала формулой Стирлинга и оценкой $n^n$:

$$
n \ln n - n < \ln n! < n \ln n
$$

И, как следствие, $C_n^k \geq k \ln \frac{n}{k} - n$.

Тогда левую часть без $H$ мы можем оценить снизу как:

$$ \ln \left((3n^2)C_M^B\right) \geq \ln 3n^2 +  B \ln \frac{M}{B} $$

А правую часть неравенства оценить сверху как:

$$
\frac{n!}{(B!)^{\frac{N}{B}}} \leq N \ln \frac{N}{B} + N \leq 2 N \ln \frac{N}{B}
$$

Таким образом мы получили неравенство:

$$
H \left(\ln 3n^2 + B \ln \frac{M}{B} \right) \geq 2 N \ln \frac{N}{B}
$$

Или

$$
H \geq \frac{2N \ln \frac{N}{B}}{\ln 3n^2 + B \ln \frac{M}{B}}
$$

Осталось рассмотреть два случая:

1. $\ln 3n^2 > B \ln \frac{M}{B}$ - тогда оцениваем знаменталь как $2 \ln 3n^2$, а вся дробь, опуская константы $\frac{N \ln \frac{N}{B}}{\ln n} \leq N = \Omega(n)$ случай
2. $B \ln \frac{M}{B} > \ln 3n^2$ - тогда оцениваем знаменталь как $2B \ln \frac{M}{B}$, а вся дробь, $\frac{N \ln \frac{N}{B}}{B \ln \frac{M}{B}} = \frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B}$ по свойствам лограифмов, получили второй случай $\Omega(\frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B})$.

Таким образом, мы получили два случая, которые в точности совпадают с нижней оценкой времени работы алгоритма, который мы получили примером в начале.

## Ссылки

1. [Конспекты](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=3e8ee3d1f8920a99f78d3e6de5ffe7406b085d52) профессора Yufei Tao из Chinese University of Hong Kong
