---
layout: lecture
title:  "Quick Sort"
author: i_love_myself
categories: [ sorting ]
toc: true
---

Быстрая сортировка (англ. _quick sort_) - это другая сортировка за время $O(n \log n)$. С одной стороны она похожа на сортировку слиянием - мы тоже будем использовать метод "Разделяй и властвуй", но с другой стороны, она недетерминированная, то есть в ней присутствует элемент случайности. И хотя это может показаться минусом, на практике обычно используется именно она, поскольку в среднем у нее лучше константа, а так же она нуждается всего в $O(\log n)$ дополнительной памяти в отличии от Merge Sort.

## Partition

Прежде чем переходить к сортировке, мы опять придумаем некоторый вспомогательный алгоритм, который назовем `partition`. Он будет принимать массив и опорный элемент (pivot) и возвращать массив, в котором все элементы, меньшие pivot, стоят левее него, а большие - правее.

Таким образом мы частично отсортируем массив относительно pivot. Вот как это выглядит:

TODO: find visualization

```cpp
int partition(vector<int>& a, int l, int r) {
    int pivot = a[l + rand() % (r - l)]; // выбираем случайный элемент
    int i = l, j = r;
    while (i <= j) {
        while (a[i] < pivot) ++i;
        while (a[j] > pivot) --j;
        if (i <= j) {
            swap(a[i], a[j]);
            ++i;
            --j;
        }
    }
    return i;
}
```

## Быстрая сортировка

Быстрая сортировка (англ. _Quick sort_) очень похожа на merge sort, но в ней есть одно ключевое отличие: она недетерминированная, то есть в ней присутствует элемент случайности.

Сортировка будет состоять из нескольких итераций:

1. Выбор опорного элемента (pivot) - он производится случайно.
1. Вызываем функцию partition, которая сортирует всё относительно опорного элемента. То есть все элементы, меньшие pivot, оказываются левее него, а большие - правее.
1. Рекурсивно запускаем сортировку для левой и правой частей массива.

Функция partition будет проходиться по массиву ровно один раз с помощью двух указателей - левый и правый, которые изначально стоят в самом левом и самом правом элементе массива. Если так оказывается, что левый элемент больше pivot, а правый - меньше, то меняем их местами. Иначе двигаем один из указателей (тот, который ок, то есть если левый элемент меньше pivot, то он ок и двигаем его, аналогично с правым).

Добавим сюда визуализацию:

![Quick sort](./img/quick_sort.gif)

Если хотите посмотреть, как работает быстрая сортировка на примере танца (вдруг), то [Quick-sort with Hungarian](https://youtu.be/ywWBy6J5gz8) вам поможет.

## Время работы

::: theorem
**Теорема о времени работы быстрой сортировки**

1. Быстрая сортировка работает за $O(n \log n)$ в среднем.
2. Вероятность того, что глубина рекурсии будет больше $const \cdot \log n$ убывает экпоненциально с ростом $const$.
:::

Во-первых, будем доказывать утверждение для случая, когда все элементы различны в предположении, что можно сделать линейную пред/пост обработку, чтобы все элементы были различны. Во-вторых, первая часть теоремы будет доказываться тривиально, а вот вторая будет доступна только студентам, хорошо знакомым с основами дискретной математики.

<details markdown="1">
<summary>Доказательство индукцией</summary>
Докажем по индукции, что время работы алгоритма сортировки $T(n) <= C n \log n$, где $C = 3$.

**База индукции:** $n = 1$. В этом случае алгоритм работает за $O(1)$.

**Предположение индукции:** пусть для всех $k < n$ время работы алгоритма $T(k) \leq 3 \cdot k \log k$.

**Шаг индукции:** пусть $n$ - размер массива.

Так как мы выбираем случайный элемент в качестве опорного, то вероятность того, что он окажется $i$-м по величине элементом равна $\frac{1}{n}$. В каждом из этих случаев мы выполним $n$ операций в функции `partition` и рекурсивно запустимся для двух подзадач размера $i$ и $n - i - 1$. Тогда среднее время работы алгоритма можно записать как:

$T(n) = n + \frac{1}{n} \sum\limits_{i=0}^{n-1} (T(i) + T(n-i-1)) = n + \frac{2}{n}\sum\limits_{i=0}^{n-1} T(i)$

Домножим всё на $n$:

Применяя предположение индукции, распишем сумму:

$\frac{2}{n}\sum\limits_{i=0}^{n-1} T(i) = \frac{2C}{n} \sum\limits_{i=1}^{n - 1} i \log i \leq \frac{2C}{n}\sum\limits_{i=1}^{n}i \log n = \frac{2C}{n}\log n \sum\limits_{i=1}^{n-1} \leq \frac{2C}{n} \log n \frac{(n - 1)(n - 2)}{2} = \frac{С(n - 1)(n - 2)}{n}\log n$

Почти готово, вспоминаем, что мы хотели доказать:

$T(n) = n + \frac{2}{n}\sum\limits_{i=0}^{n-1} T(i) \leq n + C n \log n - C \log n = C n \log n + (n - C \log n)$

Упс, не сошлось :(

</details>

<details markdown="1">
<summary>Доказательство матожиданием</summary>
TODO
</details>

<details markdown="1">
<summary>Экпоненциально низкой вероятности "глубокой" рекурсии</summary>
TODO
</details>

## k-ая порядковая статистика

TODO: написать про k-ую порядковую статистику
