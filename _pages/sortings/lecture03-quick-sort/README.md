---
layout: lecture
title:  "Quick Sort"
author: i_love_myself
categories: [ sorting ]
toc: true
---

Быстрая сортировка (англ. _quick sort_) - это другая сортировка за время $O(n \log n)$. С одной стороны она похожа на сортировку слиянием - мы тоже будем использовать метод "Разделяй и властвуй", но с другой стороны, она недетерминированная, то есть в ней присутствует элемент случайности. И хотя это может показаться минусом, на практике обычно используется именно она, поскольку в среднем у нее лучше константа, а так же она нуждается всего в $O(\log n)$ дополнительной памяти в отличии от Merge Sort.

## Partition

Прежде чем переходить к сортировке, мы опять придумаем некоторый вспомогательный алгоритм, который назовем `partition`. Он будет принимать массив и опорный элемент (pivot) и возвращать массив, в котором все элементы, меньшие pivot, стоят левее него, а большие - правее.

Таким образом мы частично отсортируем массив относительно pivot. Вот как это выглядит:

TODO: find visualization

```cpp
int partition(vector<int>& a, int l, int r) {
    int pivot = a[l + rand() % (r - l)]; // выбираем случайный элемент
    int i = l, j = r;
    while (i <= j) {
        while (a[i] < pivot) ++i;
        while (a[j] > pivot) --j;
        if (i <= j) {
            swap(a[i], a[j]);
            ++i;
            --j;
        }
    }
    return i;
}
```

## Быстрая сортировка

Быстрая сортировка (англ. _Quick sort_) очень похожа на merge sort, но в ней есть одно ключевое отличие: она недетерминированная, то есть в ней присутствует элемент случайности.

Сортировка будет состоять из нескольких итераций:

1. Выбор опорного элемента (pivot) - он производится случайно.
1. Вызываем функцию partition, которая сортирует всё относительно опорного элемента. То есть все элементы, меньшие pivot, оказываются левее него, а большие - правее.
1. Рекурсивно запускаем сортировку для левой и правой частей массива.

Функция partition будет проходиться по массиву ровно один раз с помощью двух указателей - левый и правый, которые изначально стоят в самом левом и самом правом элементе массива. Если так оказывается, что левый элемент больше pivot, а правый - меньше, то меняем их местами. Иначе двигаем один из указателей (тот, который ок, то есть если левый элемент меньше pivot, то он ок и двигаем его, аналогично с правым).

Добавим сюда визуализацию:

![Quick sort](./img/quick_sort.gif)

Если хотите посмотреть, как работает быстрая сортировка на примере танца (вдруг), то [Quick-sort with Hungarian](https://youtu.be/ywWBy6J5gz8) вам поможет.

## Время работы

::: theorem
**Теорема о времени работы быстрой сортировки**

1. Быстрая сортировка работает за $O(n \log n)$ в среднем.
2. Вероятность того, что глубина рекурсии будет больше $const \cdot \log n$ убывает экпоненциально с ростом $const$.
:::

Во-первых, будем доказывать утверждение для случая, когда все элементы различны в предположении, что можно сделать линейную пред/пост обработку, чтобы все элементы были различны. Во-вторых, первая часть теоремы будет доказываться тривиально, а вот вторая будет доступна только студентам, хорошо знакомым с основами дискретной математики.

<details markdown="1">
<summary>Доказательство индукцией</summary>

Начнем с некоторой вспомогательной леммы:

**Лемма:** $\sum\limits_{i=1}^{n - 1}k \log k \leq \frac{n^2}{2} \log n - \frac{3n^2}{8}$.

<details markdown="1">
<summary>Доказательство леммы</summary>

Прибавим и вычтем $\sum\limits_{k=1}^{n - 1}k \log n = \frac{n(n - 1)}{2}\log n$:

$\sum\limits_{i=1}^{n - 1}k = \frac{n(n - 1)}{2}\log n + \sum\limits_{k=1}^{n - 1}(k \log k - k \log n)$

Первое слагаемое оценим сверху как $\frac{n^2}{2} \log n$. Второе слагаемое оцениваем чуть сложнее:

$\sum\limits_{k=1}^{n - 1}(k \log k - k \log n) = \sum\limits_{k=1}^{n - 1}k (\log k - \log n) = \sum\limits_{k=1}^{n - 1}k \log \frac{k}{n}$

Поскольку $k \leq n$, то каждое слагаемое не превосходит нуля (логарифм отрицательный). Оставим от суммы только вторую половину слагаемых, то есть ту, у которых $k \geq \frac{n}{2}$, следовательно их логарим не превосходит $-1$. Тогда:

$\sum\limits_{k=1}^{n - 1}k \log \frac{k}{n} \geq \sum\limits_{k=\frac{n}{2}}^{n - 1}k \cdot (-1)$

Последнюю сумму мы отдельно посчитаем как сумму африметичекой прогрессии:

$\sum\limits_{k=\frac{n}{2}}^{n - 1}k = \frac{3n^2 - 2n}{8} \leq \frac{3n^2}{8}$

Наконец, просуммировов оценки:

$\sum\limits_{i=1}^{n - 1}k \log k \leq \frac{n^2}{2} \log n - \frac{3n^2}{8}$.
</details>

Вернемся к основному утверждению и докажем его по индукции. А именно время работы алгоритма сортировки $T(n) <= C n \log n$, где $C = 1.5$.

**База индукции:** $n = 1$. В этом случае алгоритм работает за 0 операций. При $n=2$ алгоритм сделает 1 операцию.

**Предположение индукции:** пусть для всех $k < n$ время работы алгоритма $T(k) \leq C \cdot k \log k$.

**Шаг индукции:** пусть $n$ - размер массива.

Так как мы выбираем случайный элемент в качестве опорного, то вероятность того, что он окажется $i$-м в отсортированном массиве (что равносильно быть на $i$-й позиции после функции `partition`) равна $\frac{1}{n}$. В каждом из этих случаев мы выполним $n$ операций сравнения в функции `partition` и рекурсивно запустимся для двух подзадач размера $i$ и $n - i - 1$. Тогда среднее время работы алгоритма можно записать как:

$T(n) = n + \frac{1}{n} \sum\limits_{k=0}^{n-1} (T(k) + T(n-k-1)) = n + \frac{2}{n}\sum\limits_{k=0}^{n-1} T(k)$

Применяя предположение индукции, и $T(0) = 0$, распишем сумму:

$T(n) = n + \frac{2}{n}\sum\limits_{k=0}^{n-1} T(k) = \frac{2C}{n} \sum\limits_{k=1}^{n - 1} k \log k$

Теперь применим лемму:

$T(n) = n + \frac{2C}{n} \sum\limits_{k=1}^{n - 1} k \log k \leq n + \frac{2C}{n} \left( \frac{n^2}{2} \log n - \frac{3n^2}{8}\right)$

Расскроем скобки и упростим:

$T(n) \leq C n \log n + (1 - \frac{3C}{4})n$

При $C=1.5$ неравенство верно, что и требовалось доказать.

</details>

<details markdown="1">
<summary>Доказательство матожиданием</summary>
TODO
</details>

<details markdown="1">
<summary>Экпоненциально низкой вероятности "глубокой" рекурсии</summary>
TODO
</details>

## k-ая порядковая статистика

TODO: написать про k-ую порядковую статистику
