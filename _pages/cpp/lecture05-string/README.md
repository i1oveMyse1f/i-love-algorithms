---
layout: lecture
title:  "Работа со строками"
author: i_love_myself
categories: [ cpp ]
toc: true
---
## char

Напомню, что в прошлой лекции мы говорили в том числе и о целочисленных переменных. В этот раз мы остановимся более детально на типе ``char``. Он выделяется из обычных целочисленных типов (таких как ``short``, ``int`` и ``long long``). Например, если мы напишем в программе:

```c++
char c = 65;
cout << c;
```

то внезапно увидим не 65, а единственный символ - заглавную латинскую букву ``A``.

Это происходит, потому что при выводе переменной типа ``char`` С++ считает, что мы хотим вывести символ (англ. char). Осталось ответить на главный вопрос:

> А почему выводится именно ``A``?

### ASCII table

В далёком 1963 году люди решили стандартизировать таблицу между символами и числами. Этот стандарт они назвали ASKII-таблицей, и ниже вы можете увидеть таблицу, преобразующую числа от 0 до 127 в сиволы.

![img/ASCII_Code_Chart.svg](img/ASCII_Code_Chart.svg)

1. Нумерация колонок здесь в 16-ричной системе счисления. То есть, если вы смотртие на яцейку в строке i, столбце j, то её номер - i*16+j. Например, в 4-й строке 1-м столбце (4* 16 + 1 = 65 клетке) находится та самая буква ``A``.
2. Символы с 0 по 31 являюся служебными
3. Символы с 32 по 127 можно спокойно печатать и не бояться за жизнь

Безусловно, вам не надо запоминать ACKII-таблицу. Если вам интересен, какой порядковый номер имеет тот или иной символ, то вы можете запустить простейший код:

```c++
int c = 'z';
cout << z;
```

На самом деле при вниметельном рассмотрении таблицы должен возникнуть очередной вопрос:

> А как же хранятся русские символы?

При более внимательном рассмотрении возниакет ещё одна мысль. Вы могли заметить, что мы использовали "не весь потанцеал" типа ``char``. А именно, тип 8-битный, то есть в нем можно хранить числа от 0 до 255, а таблицу мы заполнили только до 127.

> Кто украл вторую половину таблицы, Билли?

Эти два вопроса связаны.

### Вторая половина ASKII-таблицы

Вторую часть таблицы было принято отдать "на outsource". В разных страных разные буквы, поэтому вторая часть таблицы зависит от раскладки вашей клавиатуры. Более того, даже если вы в России, то существут разные вторые части таблицы, такие как CP1251, KOI8-R и другие, они называются кодировка.

CP1251 выглядит так:
![CP1251](https://upload.wikimedia.org/wikipedia/commons/2/2a/Windows-1251-upper-half.gif?uselang=ru)

KOI8-U выглядит так:
![KOI8-U](https://cf.ppt-online.org/files/slide/c/cjROWq78doB23xePwzHUuZlLAmDn9k1KFQNhSE/slide-5.jpg)

На самом деле это сущий кошмар, и в жизни вы ни раз столкнетесь с проблемой кодикровки. Однако, в мире спортивного программирования все сиволы находятся в интервале от 32 до 127, а значит никаких проблем не будет.

Дотошный читатель заметит ещё две пробемы:

> В некоторых языках (например, китайских иероглифах) символов больше чем 128, как люди живут?

> Неужели, мне надо менять кодировку каждый раз, когда я хочу напечатать сивол из третьего языка?

Обе проблемы решает универсальная кодирока, именуемая [Unicode](https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4) и её модификации: UTF-8, UTF-16, UTF-32 (в зависиомти от количества бит на символ). Об этом я рассказывать не буду, но вы можете прочитать Википедию или посмотреть какое-нибудь видео на YouTube.

## String

Отлично, со строками разобрались! Теперь разбираемся с последовательностью сиволов, или строками.

Есть два ~~стула~~ способа представления строк. Первый, более очевидный, - это хранить строку в виде массива элементов типа ``char``. Например, так:

```cpp
char str[10] = { 'a', 'b', 'c' }; // Это называется список инициализации
char str[10] = "abc"; // Но можно и без него
```

К сожалению, данный подход обладает большим количеством недостатков, о которых мы обязательно поговорим, когда дойдём до итераторов.

Другой способ - это тип ``string`` (которым вы будете всегда пользоваться). Он удобен тем, что для него есть множество методов, помогающих работать со строками:

```cpp
string s = "abcd";
cout << s.substr(1, 2) << '\n'; // подстрока с 1 позиции, 2 последующих символа - "bc"
cout << s[3] << '\n'; // 'd'
cout << s.size() << '\n'; // 4
string t = "gg";
cout << t + s; // "abcdgg"
cout << (t < s); // сравнение строк лексикографически, результат - false, выведется 0
```

Обратите так же внимание на не очень очевидую типизацию в C++ при работе со строками и символами:

```cpp
"abc" // это массив символов типа const char[4]
'a' // это символ типа char
"abc"s // это строка типа string

string s = "abc"; // работает как конвертация массива в строку
string a = "abc";
string b = a + "kek"; // не работает, потому что "kek" - это const char[4], а не string

// Приучите себя писать "abc"s вместо "abc" во избежение непонятных ошибок
```

Все методы класса ``string`` вы можете найти в [документации](https://en.cppreference.com/w/cpp/string/basic_string).

## Решаем пару задач

> Группа студентов написала экзамен в виде теста. Всего в группе было $n$ студентов, а тест состоял из $m$ вопросов, каждый из которых имел $5$ вариантов ответа (`A`, `B`, `C`, `D` или `Е`). На каждый вопрос есть ровно один правильный ответ. Правильный ответ на $i$-й вопрос даёт $a_i$ баллов. Неправильные ответы оцениваются нулём баллов.
> Студенты помнят, какие ответы они дали на экзамене, но не знают, какие ответы являются правильными. Они настроены достаточно оптимистично, а потому интересуются насколько большим может быть суммарный балл всех студентов группы.
> Напишите программу, которая по заданным ответам студентов и баллам за каждый вопрос определит максимально возможный суммарный балл всех студентов.

### [D контеста](http://codeforces.com/gym/344773/problem/D)

Не сложно заметить, что максимальный суммарный балл будет достигнут в случае, когда правильный ответ на вопрос номер k дало больше всего студентов. Таким образом, для каждого вопроса надо найти максмиальное количество студентов, которое ответило одинаково.

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
  
    vector<vector<int>> count(m, vector<int>(5)); // массив размера M x 5, заполнен изначально нулями
    for (int i = 0; i < n; ++i) { // читаем все строки
        string s;
        cin >> s;
        for (int j = 0; j < m; ++j) {
            count[j][s[j] - 'A']++; // заполняем количество встречаемости ответа s[j] на вопрос j
        }
    }

    vector<int> a(m);
    for (int i = 0; i < m; ++i) { // читаем a
        cin >> a[i];
    }

    int ans = 0;
    for (int i = 0; i < m; ++i) { // перебираем вопросы
        int mx = 0;
        for (int j = 0; j < 5; ++j) { // ищем максимальную встречаемость на вопрос номер i
            if (count[i][j] > mx)
                mx = count[i][j];
        }
        ans += mx * a[i]; // добавляем максимум к ответу
    }
    cout << ans;
}
```

### [H контеста](http://codeforces.com/gym/344773/problem/H)

Данная задача исключительно на работу со строками. Можно пользоваться substr, можно вспомнить о find и rfind. Остановимся на первом варианте:

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    string s;
    cin >> s;

    bool has_elier_name = false;
    int n = s.size();

    vector<string> friends = { "Danil", "Olya", "Slava", "Ann", "Nikita" }; // Да, у вектора тоже есть список инициализации

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < friends.size(); ++j) {
            if (s.substr(i, friends[j].size()) == friends[j]) { // если подстрока равна j-му имени
                if (has_elier_name) { // это не первое вхождение
                    cout << "NO";
                    return 0; // завершить программу (работает только внутри main)
                }
                else {
                    has_elier_name = true;
                }
            }
        }
    }

    if (has_elier_name)
        cout << "YES";
    else
        cout << "NO";
}
```
