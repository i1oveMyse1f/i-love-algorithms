---
layout: lecture
title:  "Работа с памятью. Олимпиадный аллокатор"
author: i_love_myself
categories: [ cpp ]
toc: true
---
В олимпиадном програмировании вам обычно не нужно сталкиваться с методами, напрямую работащими с сырокй памятью в C++ (`new`, `delete`), поскольку вы используете готовую обертку - стандартные структуры данных, такие как `vector`, `set`, `map` и другие. Эти обертки сделают всё за вас и вам не придется думать о том, как же выделяется память под переменную. Однако дванный блок:

1. Даст вам больше понимания о том, как работает ваша программа и операционная система
2. Детали работы с памятью могут помочь в оптимизации кода, в частности, мы напишем свой собственный аллоктор, который значительно ускоряет работу с памятью (но чем-то жертвует).

## Области памяти в C++

В языке C++, как и в операционной системе, память для работы программы делится на две основные области:

- **Стек (stack)** — структура данных, которая организована по принципу "последним пришёл — первым вышел" (LIFO). Стек используется для хранения локальных переменных, параметров функций и данных, которые должны быть быстро доступны.
- **Куча (heap)** — область памяти для динамического выделения, где хранятся объекты и данные, размеры которых заранее неизвестны или могут изменяться во время выполнения программы.

### Отличия между стеком и кучей:

| Характеристика   | Стек                                                | Куча                |
| ---------------- | --------------------------------------------------- | ------------------- |
| Скорость доступа | Быстрая                                             | Медленная           |
| Управление       | Автоматическое                                      | Ручное              |
| Размер           | Ограничен (но в олимпиадном программировании - нет) | Большой             |
| Использование    | Локальные переменные                                | Динамические данные |

---

## Стек

### Особенности:

- Переменные в стеке создаются очень быстро. Это связано с тем, что операция выделения памяти в стеке сводится к простой модификации указателя стека.
- Переменные, созданные в стеке, автоматически удаляются при выходе из области видимости, так как стек очищается функцией, освобождающей память, после завершения вызова.
- Стековые переменные имеют фиксированный размер, который должен быть известен на этапе компиляции - это ещё одна причина быстрого создания переменных в стеке.
- Из стека невозможно эффективно удалять переменные из середины, так как структура стека допускает доступ только к вершине (последней добавленной переменной).

### Пример создания переменной в стеке:

```cpp
int arr[1000]; // На стеке

void example() {
    int a = 42; // на стеке
    int* b = &a; // на стеке
}
```

- **Важно:** Сильно упрощая, переменная на стеке — это либо базовый тип данных (например, `int` или `double`), либо указатель на объект в куче, либо массив фиксированного размера.

---

## Куча

### Особенности:

- Создание переменной в куче требует больше времени, так как операционная система должна найти подходящий участок памяти в сложной структуре данных (например, двоичное дерево или хэш-таблица).
- В куче можно создавать объекты любого размера, даже если их размер неизвестен на этапе компиляции.
- Управление памятью в куче выполняется вручную (с помощью `new` и `delete`) или автоматически (при использовании умных указателей).

### Пример создания переменной в куче:

```cpp
void example() {
    int* a = new int(42);       // Выделение памяти под int в куче
    double* b = new double[10]; // Выделение памяти под массив из 10 элементов типа double

    delete a;                   // Удаление переменной из кучи
    delete[] b;                 // Удаление массива из кучи
}
```

- **Важно:** Не забывайте освобождать память в куче, чтобы избежать утечек памяти, если работаете с сырой памятью.

---

### Сравнение стековых и кучевых переменных:

| Особенность                         | Стек               | Куча                        |
| ----------------------------------- | ------------------ | --------------------------- |
| Время создания                      | Очень быстро       | Медленнее                   |
| Автоматическое удаление             | Да                 | Нет                         |
| Размер известен на этапе компиляции | Да                 | Нет                         |
| Возможные ошибки                    | Переполнение стека | Утечки памяти, фрагментация |

---

## Олимпиадный аллокатор

Иногда в олимпиадном программировании иногда мы можем очень сильно упростить работу сложной структуры данных-алокатора на куче. У нас будет два трюка:

1. Вместо использования кучи мы заранее зарезервируем очень много памяти на стеке.
2. Мы перестанем удалять элементы из памяти. Если ячейка памяти уже была использована, то мы просто не будем её использовать повторно.

Таким образом, мы получим очень быстрый аллокатор, но с ограничением на количество элементов, которые мы можем создать за всё время работы программы - это плата за скорость.

```cpp
const int ML = 1e8;

int pos_memory = 0;
char memory[ML];

void* operator new(size_t n) { // двигаем указатель на n байт вперёд
    char *res = memory + pos_memory;
    pos_memory += n;
    assert(pos_memory <= ML); // проверка на то что памяти хватило
    return (void*) res;
}
void operator delete(void *){} // Ничего не делаем
```

Обратите внимение, это повлияет на все стандартные контейнеры: `vector`, `set`, `map` и другие. Теперь они будут работать быстрее, но с ограничением на количество элементов, когда либо созданных за время работы программы.

Например, если ваш код делал $O(n log n)$ вставок и удалений в `set` с ограниечением на то, что всегда во множестве не больше $O(n)$ элементов, то теперь вы будете потреблять $O(n \log n)$ памяти, а не $O(n)$.
