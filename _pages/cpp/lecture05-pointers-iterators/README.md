---
layout: lecture
title:  "Указатели и итераторы"
author: i_love_myself
categories: [ cpp ]
toc: true
---

# Указатели

## Что это такое?

В компьютере есть память. Память - это большой массив ячеек, каждая из которых имеет свой адрес. Указатель - это переменная, которая хранит адрес в памяти.

Чтобы получить адрес переменной, нужно поставить перед ней знак `&`. Чтобы получить значение по адресу (разыменовать указатель), нужно поставить перед указателем знак `*`.

Например:

```cpp
int x = 5;
int* p = &x; // int* - это тип указателя на int
cout << x << endl; // 5
cout << p << endl; // адрес переменной x, например 0x7ffebc7b3b7c
cout << *p << endl; // 5
```

* Размер указателя на любой тип данных одинаков. Например, на 64-битной архитектуре указатель занимает 8 байт.
* В языке C++ есть специальное значение `nullptr`, которое означает "нет адреса". Это значение можно присвоить любому указателю.

## Массивы и указатели

На самом деле массивы в C++ - это указатели на первый элемент массива. Например:

```cpp
int a[5] = {1, 2, 3, 4, 5};
int* p = a; // указатель на первый элемент массива
cout << *p << endl; // 1
```

### Арифметика указателей

Указатели можно прибавлять (экивалетно сдвигу в индексах) и вычитать (эквивалетно расстоянию между индексами в массиве). Например:

```cpp
int a[5] = {1, 2, 3, 4, 5};
int* p = a;
int* q = p + 2; // указатель на третий элемент массива
cout << *p << endl; // 1
cout << *q << endl; // 3
cout << q - p << endl; // 2 - разница в индексах
```

# Итераторы

Прежде чем говорить о итераторах, давайте поговорим, что такое контейнеры. Контейнеры - это классы, которые хранят данные. Например, `string` - хранит массив символов, `vector` - хранит массив элементов любого типа, `set` - это отсортированное множество элементов любого типа и другие.

Контейнеры - это абстракция, которая позволяет скрыть детали реализации. Например, как хранятся данные в векторе, как добавляются элементы в множество и так далее. Однако, иногда нам нужно работать с элементами контейнера напрямую.

Мы могли бы сказать, что итератор - это указатель на элемент контейнера. Итераторы позволяют нам обходить элементы контейнера, получать доступ к элементам и изменять их, ровно так же как вы могли это делать с массивом, есть даже арифметика итераторов, но есть целый список большых но, почему итератор - это НЕ указатель:

* Какие-то контейнеры не хранят элементы в памяти последовательно (например, `deque`), поэтому "сдвинуть указатель на 10 элементов вперёд" может быть не так просто.
* Какие-то контейнеры - это деревья, поэтому "сдвинуть указатель на 10 элементов вперёд" вообще невозможно эффективно.
* Итераторы могут быть более безопасными, чем указатели. Например, итераторы вектора проверяют, что вы не обратились к несуществующему элементу.

К сожалению, на данном этапе курса по алгоритмам многие примеры могут оказаться непонятными. Чем больше примеров структур данных и алгоритмов вы изучите, тем больше поймёте, зачем нужны итераторы.

## Виды итераторов

В C++ есть несколько видов итераторов:

* `input_iterator` - итератор, который позволяет только читать элементы контейнера.
* `output_iterator` - итератор, который позволяет только писать элементы в контейнер.
* `forward_iterator` - итератор, который позволяет читать и писать элементы контейнера, но только в одном направлении.
* `bidirectional_iterator` - итератор, который позволяет читать и писать элементы контейнера в обоих направлениях.
* `random_access_iterator` - итератор, который позволяет читать и писать элементы контейнера, а также сдвигать итератор на произвольное число шагов.
* `contiguous_iterator` - итератор, который позволяет читать и писать элементы контейнера, а также сдвигать итератор на произвольное число шагов, при этом элементы контейнера хранятся в памяти последовательно.

Подробная таблица типов итераторов доступна в [документации](https://en.cppreference.com/w/cpp/iterator).

## Примеры использования итераторов

Мы познакомимся с итераторами на примере строки. Итераторы любого другого контейнера работают аналогично, однако могут не иметь части функциональности:

```cpp
string s = "abc";
for (auto it = s.begin(); it != s.end(); ++it) {
    cout << *it << endl;
}
```

* `begin()` - возвращает итератор на первый элемент контейнера.
* `end()` - возвращает итератор на элемент, следующий за последним элементом контейнера. Обратите внимание, что `end()` не указывает на последний элемент контейнера.
* `++it` - сдвигает итератор на следующий элемент.
* `*it` - разыменовывает итератор.

Обратите внимение на то, что в C++ begin и end обозначают ПОЛУИНТЕРВАЛ. Это часто вызывает путаницу у начинающих, поэтому будьте внимательны. В то же время данный подход позволяет писать более красивый код, например размер строки можно вычислить как ```end() - begin()``` без лишних `+-1`.

В C++11 появились удобные циклы для работы с контейнерами:

```cpp
string s = "abc";
for (char c : s) {
    cout << c << endl;
}
```

Такой цикл полностью эквивалентен предыдущему, но более краток и читаем.
