---
layout: lecture
title:  "Функции в языке C++"
author: i_love_myself
categories: [ cpp ]
toc: true
---
# Функции

## Что это такое?

До этого момента мы с вами писали весь код внутри main. Настал тот момент, когда мы напишем свою первую функцию. Любая функция характеризуется несколькими вещами:

1. Входные аргументы функции
2. Выходное значение функции
3. Что, собственно, делает функция

## Зачем нужны функции?

1. Увеличивать читабельность кода (следовательно, и отладку тоже)
2. Убирать дублирование кода
3. Упрощать написание кода

Синтаксис и примеры:

```cpp
<output_type> function_name(<input_args>) {
    // тело функции
}

int count_bits(int x) { // функция возвращает одно число типа int и принимает одно число типа int
    int count = 0;
    while (x > 0) { // убираем по одному биту
        x = x & (x - 1);
        ++count;
    }
    return count; // возвращаем результат
}

bool has_name(string s, int pos, string t) { // возвращает bool, принимает 3 аргумента: строку s, позицию pos и строку t
    // возвращает true, если s, начиная с позции pos строка равна t
    return s.substr(pos, t.size()) == t;
}
```

Однако, в момент написания последнего примера вы должны остановиться и надавать себе по рукам. Что же мы не так сделали?

## Передача аргументов по ссылке и по значению

Если вы пишете функцию и где-то её вызываете:

```cpp
bool has_name(string s, int pos, string t) {
    return s.substr(pos, t.size()) == t;
}

int main() {
    cout << has_name("abc", 1, "bc");
}
```

то вы должны осознавать, что в функцию будет передана КОПИЯ строки s, КОПИЯ строки t и КОПИЯ переменной pos. Это сделано для того, чтобы вы могли внутри функции менять данные переменные как хотите.

```cpp
void func(string s) { // void - когда функция ничего не возвращает
    s = "haha classic";
}

int main() {
    string s = "abc";
    func(s);
    cout << s; // abc
}
```

Однако, в данный момент стоит задуматься о времени работы программы. кпоирование строки происходит абсолютно в лоб, то есть за длину строки. Таким образом, если вы вызовите 1000 раз данную функцию для строк длины порядка 1000, то потребуется 1000*1000 операций.

**Решение:** передавать некоторые аргументы по ссылке. При передачи поссылке объект не копируется. При этом если вы поменяете объект внутри функции, то и вне функции он тоже изменится. Синтаксис следующий:

```cpp
void func(string& s) {
    s = "haha classic";
}

int main() {
    string s = "abc";
    func(s);
    cout << s; // haha classic
}
```

Какие объекты стоит передавать по ссылке: примерно все объекты, занимающие больше 16 байт. Это включает в себя строки, вектора, массивы и т.д.

В промышленном программировании никто не передает объекты по обычной ссылке. Вместо этого используют ``const`` ссылки. Это позволяет избежать случайного изменения объекта внутри функции. Синтаксис:

```cpp
void func(const string& s) {
    s = "haha classic"; // ошибка компиляции
}
```

Если же функция меняет объект, то измененную переменную либо возвращают, либо передают по указателю (поговорим, что это позже). Пример:

```cpp
void func_pointer(string* s) {
    *s = "haha classic";
}

string func_return(const string& s) {
    return "haha classic";
}
```
