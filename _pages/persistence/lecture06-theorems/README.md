---
layout: lecture
title:  "Теоремы о персистентности"
author: i_love_myself
categories: [ persistence ]
toc: true
---

### Модель указателей

В самом начале курса мы с вами ввели понятие RAM-модели - модели памяти вычислений, которая имеет Random Access и понятный набор простейших операций. Сейчас по аналогии мы введем модель указателей, которая пригодится нам для теорем о персистентности.

**Модель указателей** (англ. pointer machine model) - это модель вычислений, которая оперирует независимыми вершинами, каждая из которых может хранить **константное** количество бит информации: это могут быть указатели на другие вершины или какие-то данные.

Например, стек, дерево отрезков или двусвязный список прекрасно ложатся в эту модель, а вот массивы - нет. Подумайте, почему!

### Теорема о частичной персистентности

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ в модели указателей отвечает на запросы за $O(T)$ и степень входа в каждую вершину не больше константы $P$, тогда мы можем построить структуру данных $D'$ с частичной персистентностью, которая отвечает на запросы за $O(T)$, потратив $O(q)$ дополнительной памяти, где $q$ - количество запросов к структуре данных $D$.
</div>

Построение и доказательство полностью аналогично тому, что мы делали в случае частично персистентного двусвязного списка, только теперь при копировании вершины нам, возможно, придется пройтись по всем вершинам, которые на нее указывали, но это константа вершин, поэтому асимптотика не изменится.

### Теорема о полной персистентности

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ в модели указателей отвечает на запросы за $O(T)$ и степень входа в каждую вершину не больше константы $P$, тогда мы можем построить структуру данных $D'$ с полной персистентностью, которая отвечает на запросы за $O(T)$, потратив $O(q)$ дополнительной памяти, где $q$ - количество запросов к структуре данных $D$.
</div>

Оказывается можно добиться и полной персистентности, однако это крайне непросто и требует нескольких дополнительных разделов. В общих чертах можно прочитать на [neerc](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BD.D1.82.D0.BD.D1.8B.D1.85_.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.B4.D0.BB.D1.8F_.D1.80.D0.B5.D1.88.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B3.D0.B5.D0.BE.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87).

### Что делать, если степень вершины не константная?

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ в модели указателей отвечает на запросы за $O(T)$ и степень входа в каждую вершину не ограничена, тогда мы можем построить структуру данных $D'$ в модели указателей с ограниченной степенью каждой вершины, однако будем терять $O(\log n)$ на каждый запрос.
</div>

Для этого мы можем разбить вершину в большой степенью входа на целое сбалансировнное дерево логарифмической глубины, оно всё будет отвечать за одну вершину, но при этом потребуется лишний логарифм, чтобы дойти до корня (зато степень каждой вершины ограничена).

### О преобразовании RAM в модель указателей

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ в RAM-модели отвечает на запросы за $O(T)$, тогда мы можем построить структуру данных $D'$ в модели указателей, но время ответа на запрос увеличится до $O(T \log n)$.
</div>

Для этого по сути нужно построить деревья отрезков в местах, где в структуре есть массивы, так мы избавимся от Random Access, но придется потратить лишний $O(\log n)$ на каждый запрос.

Иначе говоря, мы можем произвольную структуру сделать полностью персистентной и в худшем случае потеряем $O(\log n)$ на каждый запрос, но в некоторых частных случаях даже этот логарифм можно оптимизировать!
