---
layout: lecture
title:  "Теоремы о персистентности"
author: i_love_myself
categories: [ persistence ]
toc: true
---

### Модель указалетей

В самом начале курса мы с вами ввели понятие RAM-модели - модели памяти вычислений, которая имеет Random Access и понятный набор простейших операций. Сейчас по аналогии мы введем модель указателей, которая пригодится нам для теорем о персистентности.

**Модель указателей** (англ. pointer machine model) - это модель вычислений, которая оперирует независимыми вершинами, каждая из которых может хранить **константное** количество бит информации: это могут быть указатели на другие вершины или какие-то данные.

Например, стек, дерево отрезков или двусвязный список прекрасно ложатся в эту модель, а вот массивы - нет. Подумайте, почему!

### Теорема о частичной персистентности

<div markdown="1" class="alert alert-theorem">
Пусть струтура данных $D$ отвечает на запросы за $O(T)$ и степень входа в каждую вершину не больше константы $P$, тогда мы можем построить структуру данных $D'$ с частичной персистентностью, которая отвечает на запросы за $O(T)$, потратив $O(q)$ дополнительной памяти, где $q$ - количество запросов к структуре данных $D$.
</div>

Построение и доказательтство аналогично тому, что мы делали в случае частично персистентного двусвязного списка, только теперь при копировании вершины нам, возможно, придется пройтись по всем вершинам, которые на нее указывали, но это константа вершин, поэтому асимптотика не изменится.

### Теорема о полной персистентности

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ отвечает на запросы за $O(T)$ и степень входа в каждую вершину не больше константы $P$, тогда мы можем построить структуру данных $D'$ с полной персистентностью, которая отвечает на запросы за $O(T)$, потратив $O(q)$ дополнительной памяти, где $q$ - количество запросов к структуре данных $D$.
</div>

Оказывается можно добиться и полной персистентности, однако это крайне непросто и требует нескольких дополнительных разделов. В общих чертах можно прочитать на [neerc](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BD.D1.82.D0.BD.D1.8B.D1.85_.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.B4.D0.BB.D1.8F_.D1.80.D0.B5.D1.88.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B3.D0.B5.D0.BE.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87).

### О преобразовании RAM в модель указателей

<div markdown="1" class="alert alert-theorem">
Пусть структура данных $D$ отвечает на запросы за $O(T)$ в RAM-модели, тогда мы можем построить структуру данных $D'$ в модели указателей, которая отвечает на запросы за $O(T \log n)$
</div>

Для этого по сути нужно построить деревья отрезков в местах, где в структуре есть массивы, так мы избавимся от Random Access, но придется потратить лишний $O(\log n)$ на каждый запрос.

Иначе говоря, мы можем произвольную структуру сделать полностью персистентной, если она использует массивы, то в худшем случае потерем $O(\log n)$ на каждый запрос, но какие-то в частных случаях даже это можно оптимизировать. Конечно, всё это при условии, что степень входа в каждую вершину не больше константы $P$.
